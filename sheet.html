<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Character Sheet</title>
  <style>
  /* Transparent background so the widget has no solid box */
  body{font-family:Arial;margin:20px;background:transparent;color:#222}
    h1{margin-bottom:8px;font-size:1.4rem}
  /* Highlighted title: white text with stroke */
    .name-badge {
    color: #ffffff;
    -webkit-text-stroke: 1.5px #333333;
    text-shadow: 
        1px 1px 0 #333, 
        -1px 1px 0 #333, 
        1px -1px 0 #333, 
        -1px -1px 0 #333,
        0 1px 0 #333,
        0 -1px 0 #333,
        1px 0 0 #333,
        -1px 0 0 #333;
    padding: 6px 10px;
    display: inline-block;
    font-size: 2rem; /* ← aumenta el tamaño del título */
    }
  ul{list-style:none;padding:0;margin:0}
  li{background:#fff;padding:10px;margin:8px 0;border-radius:8px;box-shadow:0 1px 4px rgba(0,0,0,0.06)}
  strong{display:inline-block;width:140px;color:#444}
  li.section-title{background:transparent;padding:6px 8px;margin:12px 0 6px 0;border-radius:4px;font-weight:700;color:#333;font-size:1rem;}
    #trace{display:none;background:#111;color:#e6e6e6;padding:12px;border-radius:8px;font-family:monospace;white-space:pre-wrap;max-height:50vh;overflow:auto;margin-top:12px}
    .err{color:#ff6666}
    #status{color:#666;margin-bottom:10px}
  </style>
</head>
<body>
  <!-- Title: will be updated to "<Full name>'s sheet" -->
  <h1>Character Sheet</h1>
  <!-- Toggleable status -->
  <div id="status" aria-live="polite">Loading…</div>
  <ul id="characterData" aria-live="polite"></ul>

  <!-- trace panel (hidden until error) -->
  <div id="trace" role="log" aria-hidden="true"></div>

<script>
  // === CONFIG ===
  const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vR0iPs6gXT9DsZX591X0bGdROgypuxJ-b2_ygQb9L2ZgnsSv2j4OGkz_D1oe75T4uTBA6YFgjzXq_TC/pub?gid=0&single=true&output=csv";
  const params = new URLSearchParams(window.location.search);
  const CHARACTER_ID = params.get('id') || '1';

  // === Buffered logging until an error occurs ===
  let traceVisible = false;
  const logBuffer = [];

  function _appendToTraceDOM(text, type='info') {
    const t = document.getElementById('trace');
    const entry = text + '\n';
    t.textContent += entry;
    if (type === 'err') console.error(`[trace] ${text}`); else console.log(`[trace] ${text}`);
  }

  function showTraceNow() {
    if (traceVisible) return;
    traceVisible = true;
    const t = document.getElementById('trace');
    t.style.display = 'block';
    t.setAttribute('aria-hidden','false');
    for (const item of logBuffer) _appendToTraceDOM(item.msg, item.type);
    logBuffer.length = 0;
  }

  function log(msg, type='info') {
    const ts = new Date().toISOString();
    const text = `[${ts}] ${msg}`;
    logBuffer.push({msg: text, type});
    if (traceVisible) _appendToTraceDOM(text, type);
  }

  // === Robust CSV parsing ===
  function detectSeparator(sample) {
    const commas = (sample.match(/,/g)||[]).length;
    const semis = (sample.match(/;/g)||[]).length;
    return semis > commas ? ';' : ',';
  }

  function parseCSV(text, sep=',') {
    const rows = [];
    let cur = '', row = [], inQuotes = false;
    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      const next = text[i+1];
      if (ch === '"') {
        if (inQuotes && next === '"') { cur += '"'; i++; }
        else inQuotes = !inQuotes;
      } else if (ch === sep && !inQuotes) {
        row.push(cur); cur = '';
      } else if ((ch === '\n' || ch === '\r') && !inQuotes) {
        if (ch === '\r' && next === '\n') { i++; }
        row.push(cur); rows.push(row); row = []; cur = '';
      } else {
        cur += ch;
      }
    }
    if (cur !== '' || row.length) { row.push(cur); rows.push(row); }
    return rows.map(r => r.map(f => (f||'').replace(/^"|"$/g,'').trim()));
  }

  // Find header index for "Full name" with tolerant matching
  function findFullNameIndex(headers) {
    for (let i = 0; i < headers.length; i++) {
      const h = (headers[i] || '').toString().toLowerCase().replace(/\s+/g,' ').trim();
      if (h === 'full name' || h === 'fullname' || h === 'name' || (h.includes('full') && h.includes('name'))) return i;
    }
    return -1;
  }

  // === Main logic ===
  async function loadCharacter() {
    const status = document.getElementById('status');
    const container = document.getElementById('characterData');
    const title = document.querySelector('h1');

    try {
      log(`Attempting fetch of SHEET_URL: ${SHEET_URL}`);
      const start = performance.now();
      const res = await fetch(SHEET_URL, { cache: 'no-store' });
      const took = (performance.now() - start).toFixed(1);
      log(`Fetch completed - status: ${res.status} ${res.statusText} (took ${took} ms)`);

      const ct = res.headers.get('content-type') || '';
      log(`Response content-type: ${ct}`);

      const text = await res.text();
      log(`Response length: ${text.length} characters.`);

      const trimmed = text.trim().slice(0,200).toLowerCase();
      if (trimmed.startsWith('<!doctype') || trimmed.startsWith('<html') || trimmed.includes('<div')) {
        log('Detected HTML in response -> probable editor page or error page (not CSV).', 'err');
        showTraceNow();
        status.textContent = 'Error: response is HTML, not CSV';
        container.innerHTML = `<li class="err">Response looks like HTML (not CSV). Make sure you published the sheet to the web and use the CSV <code>pub?output=csv</code> URL.</li>`;
        return;
      }

      const sep = detectSeparator(text.slice(0,1000));
      log(`Detected separator: "${sep}"`);
      const rows = parseCSV(text, sep);
      log(`Parsed rows: ${rows.length}`);
      if (rows.length < 2) {
        log('No data rows parsed from CSV', 'err');
        showTraceNow();
        status.textContent = 'Error: no data rows';
        container.innerHTML = `<li class="err">No data rows parsed from CSV.</li>`;
        return;
      }

      const headers = rows[0].map(h => h.trim());
      log(`Headers (${headers.length}): ${headers.join(' | ')}`);

      const matchIndex = rows.findIndex(r => (r[0]||'').toString().trim() === CHARACTER_ID.toString().trim());
      log(`Searching for ID "${CHARACTER_ID}" in column 0 -> found index: ${matchIndex}`);

      if (matchIndex === -1) {
        log('ID not found in sheet. Will show trace.', 'err');
        showTraceNow();
        const ids = rows.slice(1,31).map(r => (r[0]||'').toString().trim());
        status.textContent = `Character ID "${CHARACTER_ID}" not found`;
        container.innerHTML = `<li class="err">No character found with ID "${CHARACTER_ID}".<br>Available IDs (first 30): ${ids.join(', ')}</li>`;
        return;
      }

  // Success — prepare data
      const row = rows[matchIndex];
      const fullNameIdx = findFullNameIndex(headers);
      const fullnameVal = (fullNameIdx !== -1 ? (row[fullNameIdx] || '') : (row[1] || '')) || 'Character';

  // Title: "<Full name>'s sheet"
  title.textContent = `${fullnameVal}'s sheet`;
  // apply the class that paints the text white and adds a gray stroke
  title.classList.add('name-badge');

  // Hide status
      status.textContent = '';
      status.style.display = 'none';

      // --- Custom section and field order ---
      container.innerHTML = '';
      const skip = new Set([0]);
      if (fullNameIdx !== -1) skip.add(fullNameIdx);
      // Map: header label (lowercase, trimmed) -> value
      const fieldMap = {};
      for (let i = 0; i < headers.length; i++) {
        if (skip.has(i)) continue;
        fieldMap[headers[i].toLowerCase().trim()] = row[i] || '—';
      }

      // Section definitions: array of {title, fields: [header]}
      const sections = [
        {title: 'Basic Information', fields: [
          'full name','title','place of birth','species','age','date of birth','status (alive or dead)']},
        {title: 'Physical Appearance', fields: [
          'height','weight','hair color and style','eye color','skin color or texture','distinctive marks (tattoos, scars, etc.)']},
        {title: 'Psychological Traits', fields: [
          'personality','moral compass','strengths','weaknesses','motivation','fears','sense of humor']},
        {title: 'Relationships and Work', fields: [
          'occupation','family','best friends','enemies','romantic partner or relationships']},
        {title: 'Likes and Preferences', fields: [
          'likes','dislikes','hobbies','favorite animal','favorite food','favorite drink','favorite color']},
        {title: 'Health and Well-being', fields: [
          'blood type','gender','energy levels','allergies']},
        {title: 'History and Experiences', fields: [
          'major achievements','long-term dreams or goals','life-changing experiences']},
        {title: 'Other', fields: [
          'special skills or talents','quirks or habits','philosophy of life']},
        {title: 'Equipment', fields: [
          'weapons','armor','miscellaneous gear']},
        {title: 'Extra', fields: ['extra']}
      ];

      // Render in order, only if field exists
      for (const section of sections) {
        let hasAny = false;
        for (const field of section.fields) {
          if (fieldMap[field.toLowerCase().trim()]) { hasAny = true; break; }
        }
        if (!hasAny) continue;
        container.innerHTML += `<li class="section-title">${section.title}</li>`;
        for (const field of section.fields) {
          const val = fieldMap[field.toLowerCase().trim()];
          if (val !== undefined) {
            container.innerHTML += `<li><strong>${field}:</strong> ${val}</li>`;
            delete fieldMap[field.toLowerCase().trim()];
          }
        }
      }
      // Any remaining fields (not mapped) go to Extra
      const extraKeys = Object.keys(fieldMap);
      if (extraKeys.length) {
        container.innerHTML += `<li class="section-title">Extra</li>`;
        for (const k of extraKeys) {
          container.innerHTML += `<li><strong>${k}:</strong> ${fieldMap[k]}</li>`;
        }
      }

    } catch (err) {
      log(`Fetch/processing error: ${err}`, 'err');
      showTraceNow();
      document.getElementById('status').textContent = 'Error fetching data';
      document.getElementById('characterData').innerHTML =
        `<li class="err">Fetch error: ${err.message || err}</li>
         <li class="err">If you see <code>TypeError: Failed to fetch</code>, check permissions/CORS and use the CSV <code>pub?output=csv</code> URL.</li>`;
    }
  }

  loadCharacter();
</script>
</body>
</html>
